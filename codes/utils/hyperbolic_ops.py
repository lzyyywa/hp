"""
Implementation of common operations for the Lorentz model of hyperbolic geometry.
STRICTLY ALIGNED with HyCoCLIP (ICLR 2025) logic.
Numerical stability enhanced for mixed-precision training compatibility.
"""
import math
import torch
import torch.nn.functional as F

class LorentzMath:
    """
    Wrapper class to provide HyCoCLIP's math operations via a static interface.
    Handles the conversion between Space-only (HyCoCLIP style) and Space-Time (D+1) logic implicitly.
    """
    
    @staticmethod
    def _calc_time(x_space, c=1.0):
        """
        Calculate time component from space component: t = sqrt(1/c + |x|^2)
        HyCoCLIP logic.
        """
        return torch.sqrt(1.0 / c + torch.sum(x_space**2, dim=-1, keepdim=True))

    @staticmethod
    def exp_map_0(x, c=1.0, eps=1e-8):
        """
        HyCoCLIP's exp_map0 logic.
        Input: x (Euclidean tangent vector at origin) [..., D]
        Output: Hyperbolic vector [..., D+1] (Time, Space)
        """
        # HyCoCLIP: lorentz.py line 79
        # rc_xnorm = sqrt(c) * |x|
        rc_xnorm = (c**0.5) * torch.norm(x, dim=-1, keepdim=True)
        
        # Clamp to avoid overflow/underflow in sinh/cosh
        # math.asinh(2**15) approx 11.0. sinh(11) is approx 30000.
        # This prevents Infinity in FP16/FP32.
        sinh_input = torch.clamp(rc_xnorm, min=eps, max=math.asinh(2**15))
        
        # Space components: sinh(r) * (x / |x|) * (1/sqrt(c))
        # Derived: (sinh(r) * x) / rc_xnorm
        x_space = (torch.sinh(sinh_input) * x) / torch.clamp(rc_xnorm, min=eps)
        
        # Time component (Calculated explicitly)
        # t = cosh(r) / sqrt(c)
        x_time = torch.cosh(sinh_input) / (c**0.5) 
        
        # Return D+1 vector [Time, Space]
        return torch.cat([x_time, x_space], dim=-1)
        
    @staticmethod
    def hyp_distance(x, y, c=1.0, keepdim=False, eps=1e-8):
        """
        HyCoCLIP's pairwise_dist logic.
        Input x, y: [..., D+1] (Time, Space)
        
        [STABILITY FIX] 
        Increased default eps to 1e-5 to prevent NaN gradients in acosh.
        acosh(1) has infinite gradient. We must stay safely away from 1.0.
        """
        # Separate Time and Space
        x_time, x_space = x[..., 0:1], x[..., 1:]
        y_time, y_space = y[..., 0:1], y[..., 1:]
        
        # Lorentz Inner Product: <x, y>_L = <x_s, y_s> - x_t * y_t
        # Since x, y are on the manifold, this inner product is always <= -1/c
        inner = torch.sum(x_space * y_space, dim=-1, keepdim=True) - x_time * y_time
        
        # Distance formula: 1/sqrt(c) * acosh(-c * <x,y>_L)
        c_inner = -c * inner
        
        # [CRITICAL] Clamp min to 1.0 + eps. 
        # If c_inner is 1.0000001, acosh is valid but gradient is massive.
        # 1.0 + 1e-5 provides a safe buffer.
        dist = torch.acosh(torch.clamp(c_inner, min=1.0 + eps)) / (c**0.5)
        
        if not keepdim:
            dist = dist.squeeze(-1)
        return dist

    @staticmethod
    def half_aperture(x, c=1.0, min_radius=0.1, eps=1e-8):
        """
        HyCoCLIP's half_aperture logic.
        Calculates the angle of the cone generated by 'min_radius' in hyperbolic space.
        Input x: [..., D+1] (Time, Space)
        """
        # Extract Space component
        x_space = x[..., 1:]
        
        norm_x = torch.norm(x_space, dim=-1)
        
        denom = norm_x * (c**0.5) + eps
        asin_input = 2 * min_radius / denom
        
        # Clamp input for asin to [-1, 1]
        asin_input = torch.clamp(asin_input, min=-1.0 + eps, max=1.0 - eps)
        
        return torch.asin(asin_input)

    @staticmethod
    def oxy_angle(x, y, c=1.0, eps=1e-8):
        """
        HyCoCLIP's oxy_angle logic (Angle between y and x at origin).
        Input x, y: [..., D+1] (Time, Space)
        """
        x_time, x_space = x[..., 0], x[..., 1:]
        y_time, y_space = y[..., 0], y[..., 1:]
        
        # Lorentz Inner Product
        inner = torch.sum(x_space * y_space, dim=-1) - x_time * y_time
        
        # c_xyl = c * <x, y>_L
        # Since inner <= -1/c, c_xyl <= -1
        c_xyl = c * inner
        
        # Numerator derived from hyperbolic law of cosines / translation
        numer = y_time + c_xyl * x_time
        
        # Denominator: sqrt(c_xyl^2 - 1)
        # Since c_xyl <= -1, c_xyl^2 >= 1. We clamp min=eps to handle numerical edge cases where c_xyl ~ -1.
        denom_sq = torch.clamp(c_xyl**2 - 1, min=eps)
        denom = torch.sqrt(denom_sq)
        
        # Final Denominator: |x_space| * denom
        x_space_norm = torch.norm(x_space, dim=-1)
        final_denom = x_space_norm * denom + eps
        
        acos_input = numer / final_denom
        
        # Clamp for acos to [-1, 1]
        acos_input = torch.clamp(acos_input, min=-1.0 + eps, max=1.0 - eps)
        
        return torch.acos(acos_input)